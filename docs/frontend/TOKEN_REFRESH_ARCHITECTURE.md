# トークンリフレッシュアーキテクチャ

## 概要

このドキュメントでは、NeuraKnot の自動トークンリフレッシュの仕組みについて説明します。

## 問題点と解決策

### 問題点

1. **アクセストークンの有効期限が短い（1 時間）**

   - ユーザーが長時間アプリを使用していると、トークンが期限切れになる
   - 期限切れ後に API 呼び出しが失敗する

2. **従来の実装の問題**
   - ミドルウェアがトークンの有効期限をチェックしていない
   - 401 エラーが発生してから初めてリフレッシュを試みる（リアクティブ）
   - ユーザーは最初のリクエスト失敗を待つ必要があり、UX が悪い

### 解決策

#### 1. ミドルウェアでのプロアクティブなトークンリフレッシュ

**場所**: `frontend/middleware.ts`

**仕組み**:

- すべてのダッシュボードへのリクエストでトークンの有効期限をチェック
- トークンが期限切れの場合、自動的にリフレッシュ
- リフレッシュ成功時は新しいトークンでリクエストを続行
- リフレッシュ失敗時はログインページへリダイレクト

**利点**:

- ユーザーが 401 エラーを見ることがない
- シームレスな体験

**コード例**:

```typescript
// JWTトークンの有効期限をチェック
function isTokenValid(token: string): { valid: boolean; expiresIn?: number } {
  const payload = JSON.parse(
    Buffer.from(parts[1].replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString()
  )

  const now = Math.floor(Date.now() / 1000)
  const expiresIn = payload.exp - now

  return { valid: expiresIn > 0, expiresIn }
}

// トークンが期限切れの場合はリフレッシュ
if (!valid) {
  const refreshResult = await refreshAccessToken(request)

  if (refreshResult.success) {
    // 新しいトークンを設定してリクエストを続行
    const response = NextResponse.next()
    response.cookies.set('access_token', refreshResult.accessToken, {...})
    return response
  } else {
    // リフレッシュ失敗 - ログインページへ
    return NextResponse.redirect(new URL('/auth/login', request.url))
  }
}
```

#### 2. クライアント側での定期的な自動リフレッシュ

**場所**: `frontend/lib/hooks/useAutoTokenRefresh.ts`

**仕組み**:

- トークンの有効期限を監視
- 有効期限の 5 分前に自動的にリフレッシュ
- リフレッシュ成功後、次回のリフレッシュをスケジュール
- ページフォーカス時にスケジュールを再評価

**利点**:

- トークンが期限切れになる前に更新される
- ユーザーは常に有効なトークンを持つ
- ミドルウェアでのリフレッシュの負荷を軽減

**コード例**:

```typescript
export function useAutoTokenRefresh() {
  useEffect(() => {
    const scheduleTokenRefresh = () => {
      const token = getAccessToken();
      const expiresIn = getTokenExpiresIn(token);

      // 有効期限の5分前（300秒前）にリフレッシュ
      const REFRESH_BEFORE_EXPIRY = 300;
      const timeUntilRefresh = Math.max(
        0,
        (expiresIn - REFRESH_BEFORE_EXPIRY) * 1000
      );

      setTimeout(async () => {
        await cognitoAuth.refreshToken();
        scheduleTokenRefresh(); // 次回のリフレッシュをスケジュール
      }, timeUntilRefresh);
    };

    scheduleTokenRefresh();
  }, []);
}
```

**使用場所**: `frontend/app/dashboard/DashboardLayoutClient.tsx`

```typescript
export function DashboardLayoutClient({ profile, user, children }) {
  // トークンの自動リフレッシュを有効化
  useAutoTokenRefresh();

  return <div>...</div>;
}
```

#### 3. LocalStorage と Cookie の併用

**仕組み**:

- アクセストークンを Cookie と LocalStorage の両方に保存
- Cookie: サーバーサイドでの認証に使用
- LocalStorage: クライアント側での有効期限チェックに使用

**更新箇所**:

- `frontend/lib/auth/cognito.ts`: サインインとリフレッシュ時に LocalStorage を更新
- `frontend/app/api/auth/refresh/route.ts`: レスポンスにトークンを含める

## アーキテクチャ図

```
┌─────────────────────────────────────────────────────────────┐
│                      ユーザーがページにアクセス                    │
└───────────────────┬─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│                    Middleware（middleware.ts）                 │
│  1. トークンの存在をチェック                                      │
│  2. トークンの有効期限をチェック（JWT デコード）                    │
│  3. 期限切れの場合はリフレッシュを試みる                           │
├─────────────────────────────────────────────────────────────┤
│  ✅ トークンが有効 → リクエストを続行                              │
│  ✅ リフレッシュ成功 → 新しいトークンでリクエストを続行             │
│  ❌ リフレッシュ失敗 → ログインページへリダイレクト                  │
└───────────────────┬─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│              ダッシュボードレイアウト（Client Component）          │
│                 useAutoTokenRefresh() を実行                   │
├─────────────────────────────────────────────────────────────┤
│  1. LocalStorage からトークンを取得                            │
│  2. 有効期限を確認（JWT デコード）                               │
│  3. 有効期限の5分前にリフレッシュをスケジュール                    │
│  4. リフレッシュ実行 → LocalStorage とCookieを更新              │
│  5. 次回のリフレッシュをスケジュール                              │
└─────────────────────────────────────────────────────────────┘
```

## トークンリフレッシュのタイミング

### 1. ミドルウェア（サーバーサイド）

**タイミング**: トークンが期限切れの時
**理由**: 期限切れトークンでの API 呼び出しを防ぐ
**頻度**: ページ遷移ごと

### 2. 自動リフレッシュフック（クライアントサイド）

**タイミング**: トークンの有効期限の 5 分前
**理由**: トークンが期限切れになる前に更新し、シームレスな体験を提供
**頻度**: トークンごとに 1 回（55 分後）

### 3. 401 エラー時（フォールバック）

**タイミング**: API 呼び出しで 401 エラーが発生した時
**理由**: 上記の 2 つの仕組みが失敗した場合のフォールバック
**実装**: `useServerActionWithAuth` フック

## トークンのライフサイクル

```
ログイン
  ↓
[アクセストークン発行（有効期限: 1時間）]
  ↓
55分経過 ← useAutoTokenRefresh が自動リフレッシュ
  ↓
[新しいアクセストークン（有効期限: 1時間）]
  ↓
55分経過 ← useAutoTokenRefresh が自動リフレッシュ
  ↓
...繰り返し...
  ↓
リフレッシュトークンが期限切れ（7日後）
  ↓
ログインページへリダイレクト
```

## セキュリティ考慮事項

### 1. JWT トークンの検証

- **署名検証はしない**: ミドルウェアとクライアント側では有効期限のみチェック
- **理由**: 署名検証はバックエンド（backend-go）で行う
- **ミドルウェアの役割**: 期限切れトークンの検出と自動リフレッシュのみ

### 2. トークンの保存

- **Cookie**: `httpOnly: true`, `secure: true`, `sameSite: 'lax'`
- **LocalStorage**: クライアント側での有効期限チェックのみに使用
- **LocalStorage のリスク**: XSS 攻撃に脆弱だが、有効期限チェックのみに使用するため許容

### 3. リフレッシュトークンの保護

- **Cookie のみに保存**: LocalStorage には保存しない
- **httpOnly: true**: JavaScript からアクセス不可
- **有効期限**: 7 日間

## パフォーマンス考慮事項

### 1. ミドルウェアでのリフレッシュ

**懸念**: すべてのリクエストでトークンをチェックするとパフォーマンス問題が発生する可能性

**対策**:

- トークンが有効な場合はリフレッシュしない（期限切れ時のみ）
- クライアント側の自動リフレッシュにより、ミドルウェアでのリフレッシュ頻度を低減

### 2. クライアント側の自動リフレッシュ

**利点**:

- トークンが期限切れになる前に更新される
- ミドルウェアでのリフレッシュの必要性を大幅に削減
- ユーザー体験の向上

## トラブルシューティング

### 問題: トークンが頻繁に期限切れになる

**原因**:

- 自動リフレッシュが動作していない
- ページを長時間開いたまま放置している

**解決策**:

1. ブラウザの開発者ツールでコンソールログを確認
   - `[Auto Refresh] Token expires in...` のログが出ているか
   - `[Auto Refresh] Refreshing token...` のログが出ているか
2. LocalStorage にトークンが保存されているか確認
3. ページをリロードして自動リフレッシュが再スケジュールされるか確認

### 問題: ミドルウェアでリフレッシュが失敗する

**原因**:

- リフレッシュトークンが期限切れ（7 日間）
- バックエンドのリフレッシュエンドポイントが正常に動作していない

**解決策**:

1. リフレッシュトークンの有効期限を確認
2. バックエンドのログを確認
3. 必要に応じて再ログイン

### 問題: トークンが更新されない

**原因**:

- LocalStorage への書き込みが失敗している
- Cookie の設定が失敗している

**解決策**:

1. ブラウザの開発者ツールで以下を確認:
   - Application > Local Storage > access_token
   - Application > Cookies > access_token, refresh_token
2. コンソールログでエラーメッセージを確認
3. ネットワークタブで API 呼び出しの応答を確認

## 今後の改善案

### 1. トークンの暗号化

LocalStorage に保存するトークンを暗号化して、XSS 攻撃のリスクをさらに低減。

### 2. トークンの有効期限延長

アクティブなユーザーに対しては、トークンの有効期限を動的に延長。

### 3. オフライン対応

ネットワークエラー時にトークンリフレッシュを適切にハンドリング。

### 4. マルチタブ対応

複数のタブでアプリを開いている場合、トークンリフレッシュを同期。

## まとめ

✅ **プロアクティブなトークンリフレッシュ（ミドルウェア）**
✅ **定期的な自動リフレッシュ（クライアント側）**
✅ **401 エラー時のフォールバック**
✅ **LocalStorage と Cookie の併用**
✅ **シームレスなユーザー体験**

この設計により、ユーザーは認証状態を意識することなく、長時間アプリを使用できるようになりました。
